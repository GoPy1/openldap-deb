--- servers/slapd/overlays/ppolicy.c	2017-04-13 12:47:02.000000000 -0700
+++ servers/slapd/overlays/ppolicy.c	2017-04-13 12:47:07.000000000 -0700
@@ -41,6 +41,11 @@
 #include <ac/ctype.h>
 #include "config.h"
 
+/* Ripple WiFi */
+#include <openssl/des.h>
+#include <openssl/md4.h>
+#include "ldap_utf8.h"
+
 #ifndef MODULE_NAME_SZ
 #define MODULE_NAME_SZ 256
 #endif
@@ -257,6 +262,54 @@
 	{ NULL, 0, NULL }
 };
 
+
+/* Ripple WiFi */
+static AttributeDescription *ad_sambaNTPassword;
+
+static const char hex[] = "0123456789abcdef";
+
+#define MAX_PWLEN 256
+#define HASHLEN 16
+
+static void
+hexify( const char in[HASHLEN], struct berval *out )
+{
+	int i;
+	char *a;
+	unsigned char *b;
+
+	out->bv_val = ch_malloc(HASHLEN*2 + 1);
+	out->bv_len = HASHLEN*2;
+
+	a = out->bv_val;
+	b = (unsigned char *)in;
+	for (i=0; i<HASHLEN; i++) {
+		*a++ = hex[*b >> 4];
+		*a++ = hex[*b++ & 0x0f];
+	}
+	*a++ = '\0';
+}
+
+static void
+nthash( struct berval *passwd, struct berval *hash )
+{
+	/* Windows currently only allows 14 character passwords, but
+	 * may support up to 256 in the future. We assume this means
+	 * 256 UCS2 characters, not 256 bytes...
+	 */
+	char hbuf[HASHLEN];
+	MD4_CTX ctx;
+
+	if (passwd->bv_len > MAX_PWLEN*2)
+		passwd->bv_len = MAX_PWLEN*2;
+
+	MD4_Init( &ctx );
+	MD4_Update( &ctx, passwd->bv_val, passwd->bv_len );
+	MD4_Final( (unsigned char *)hbuf, &ctx );
+
+	hexify( hbuf, hash );
+}
+
 static int
 ppolicy_cf_default( ConfigArgs *c )
 {
@@ -2257,6 +2310,67 @@
 				rs->sr_text = txt;
 				goto return_results;
 			}
+
+			/* Ripple WiFi */
+			if ( ad_sambaNTPassword == NULL ) {
+				Debug( LDAP_DEBUG_TRACE, "ppolicy_ripple: pre slap_str2ad()\n", 0, 0, 0 );
+				const char *err;
+				int code;
+				code = slap_str2ad("sambaNTPassword", &ad_sambaNTPassword, &err);
+				Debug( LDAP_DEBUG_TRACE, "ppolicy_ripple: post slap_str2ad()\n", 0, 0, 0 );
+				if ( code != LDAP_SUCCESS ) {
+					Debug( LDAP_DEBUG_ANY, "ppolicy_ripple: "
+						"unable to find sambaNTPassword attributeType: %s (%d).\n",
+						err, code, 0 );
+					rs->sr_err = LDAP_OTHER;
+					rs->sr_text = err;
+					goto return_results;
+				}
+			}
+	
+			/* Ripple WiFi */	
+			struct berval *keys;
+			ber_len_t j, l;
+			wchar_t *wcs, wc;
+			char *c, *d;
+			struct berval pwd;
+
+			/* Expand incoming UTF8 string to UCS4 */
+			l = ldap_utf8_chars(addmod->sml_values[0].bv_val);
+			wcs = ch_malloc((l+1) * sizeof(wchar_t));
+
+			ldap_x_utf8s_to_wcs( wcs, addmod->sml_values[0].bv_val, l );
+        
+			/* Truncate UCS4 to UCS2 */
+			c = (char *)wcs;
+			for (j=0; j<l; j++) {
+				wc = wcs[j];
+				*c++ = wc & 0xff;
+				*c++ = (wc >> 8) & 0xff;
+			}
+			*c++ = 0;
+			pwd.bv_val = (char *)wcs;
+			pwd.bv_len = l * 2;
+
+                        mods = (Modifications *) ch_calloc( sizeof( Modifications ), 1 );
+                        mods->sml_op = LDAP_MOD_REPLACE;
+                        mods->sml_flags = SLAP_MOD_INTERNAL;
+                        mods->sml_desc = ad_sambaNTPassword;
+                        mods->sml_numvals = 1;
+
+			keys =  (BerVarray) ch_malloc( 2 * sizeof( struct berval ) );
+			BER_BVZERO( &keys[1] );
+			Debug( LDAP_DEBUG_TRACE, "ppolicy_ripple: nthash()\n", 0, 0, 0 );
+			nthash( &pwd, keys );
+                        mods->sml_values = keys;
+
+                        mods->sml_next = NULL;
+                        modtail->sml_next = mods;
+                        modtail = mods;
+
+			ch_free(wcs);
+			Debug( LDAP_DEBUG_TRACE, "ppolicy_ripple: done\n", 0, 0, 0 );
+
 			bv = addmod->sml_values[0];
 				/* clear and discard the clear password */
 			memset(bv.bv_val, 0, bv.bv_len);
